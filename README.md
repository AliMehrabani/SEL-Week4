# آزمایش چهارم - آزمایشگاه مهندسی نرم‌افزار
اعضای گروه: امیرحسین ندایی پور، علی مهربانی

## گزارش مراحل انجام آزمایش

همانطور که در دستور کار خواسته شده است، برنامه شرح داده شده به کمک دو الگوی طراحی state و strategy طراحی و پیاده‌سازی شده است. روند کار به این صورت بوده است که برای وضعیت ارسال و روش ارسال بسته دو واسط DeliveryState و ShippingType طراحی شده‌اند و هرکدام دو فرزند دارند که انواع این دو مورد را تشکیل می‌دهند و درون هر کلاس تابع مشخصی برای خروجی دادن داده مورد نیاز تعبیه شده است. سپس درون کلاس DeliveryContext از نوع هر کدام از واسط‌ها یک متغیر نگهداری می‌شود که نشان دهنده وضعیت و نحوه ارسال خواهند بود و در هر لحظه یکی نمونه از یکی از دو فرزند هر واسط به آن‌ها نسبت داده شده است. همچنین توابع مورد نیاز برای تغییر و گرفتن خروجی مناسب از هر کدام از آن‌ها در کلاس DeliveryContext پیاده‌سازی شده‌اند.
همچنین مطابق خواسته آزمایش، ابتدا قالب اولیه هر کلاس نوشته شده است. سپس تست‌های مورد نظر آن نوشته شده و در نهایت بدنه کلاس‌ها برای پاس شدن تست‌ها کامل شده است.
در نهایت در تصویر زیر اجرای کلاس Main را مشاهده می‌کنیم:

![image](https://github.com/AliMehrabani/SEL-Week4/assets/59169318/3a5775fb-d778-4356-9ef7-f1ae941eb6cd)

همانطور که مشاهده می‌کنیم، ابتدا وزن بسته گرفته شده است و تا زمانی که وصعیت بسته را به delivered تغییر دهیم، به ترتیب نوع ارسال و وضعیت ارسال گرفته می‌شود. در نهایت نیز آخرین روش ارسال برای محاسبه هزینه در نظر گرفته شده است.



## پاسخ پرسش‌ها

### پرسش 1

- الگوهای Creational: این الگوها روی فرآیند توسعه نرم‌افزار تمرکز دارند. یعنی اطمینان حاصل می‌کنند که توسعه نرم‌افزار ما ساده و منعطف باشد تا اگر نیاز بود بتوانیم در آینده آن را تغییر دهیم. این الگوها به جزئیات پیچیده اتصال اشیاء مختلف نرم‌افزار نمی‌پردازند.
- الگوهای Structural: این الگوها دستورالعملی برای اتصال اشیاء مختلف در نرم‌افزار هستند تا به کمک آن‌ها یک ساختاربزرگتر ساخته شود. تمرکز در این الگوهای روی اتصال این قطعات به همدیگر است به نحوی که توسعه یا تغییر سیستم در آینده بدون تغییر همه کد امکان‌پذیر باشد.
- الگوهای Behavioral: این الگوها به حل مشکلات رایج در کد کمک می‌کنند. برای مثال در این الگو مرتب بودن کد، اینکه چه قسمت‌هایی از کد کارهای یکسانی را انجام می‌دهند و چه قسمت‌هایی جزئیات عملکرد خود را پنهان می‌کنند، مهم است.

### پرسش 2

- الگوی Strategy: این الگو جزو الگوهای Behavioral است و به این معنی است که یک سری الگوریتم مختلف برای انجام یک کار تعریف کنیم و امکان جابجایی بین این الگوریتم‌ها را در حین اجرا به برنامه بدهیم.
- الگوی State: این الگو هم جزو الگوهای Behavioral است و به این معنی است که به یک شیء اجازه بدهیم عملکرد خودش را با توجه به State درونی خودش تغییر بدهد.
- الگوی Singleton: این الگو جزو الگوهای Creational است و به این معنی است که اطمینان حاصل کنیم که فقط یک شیء از یک کلاس ساخته می‌شود. به این ترتیب از هر جایی از برنامه می‌توان به عملکرد کلاس با استفاده از همین یک شیء دسترسی داشت یا آن را تغییر داد. مثلا کلاسی که با یک جدول از پایگاه داده کار می‌کند، باید از این الگو تبعیت کند تا فقط یک شیء اجازه تغییر محتویات این جدول را داشته باشد، وگرنه ممکن است دو شیء به طور همزمان در این جدول بنویسند یا از آن بخوانند که موجب عملکرد غیرمنتظره می‌شود.

### پرسش 3

الگوی Singleton. همانطور که در پرسش قبلی هم گفته شد در این الگو اطمینان حاصل می‌شود که از یک کلاس فقط یک شئ ساخته شود تا از طریق همان یک شیء از امکانات یک کلاس استفاده کنیم. نحوه تحقق این الگو به شکلی است که در تصویر زیر می‌بینید. در کلاس، امکان ساخت یک شیء را با private کردن Constructor از بین می‌بریم و بعد در متد getInstance به محض درخواست برای اولین بار، یک شیء از روی کلاس می‌سازیم که private static است و دفعه‌های بعدی همان شیء را به عنوان instance برمی‌گردانیم. به این ترتیب در طول مدت یک اجرای برنامه حداکثر یک شیء از روی این کلاس ساخته می‌شود و همه با همان یک شیء سر و کار دارند.

![singleton](https://github.com/AliMehrabani/SEL-Week4/assets/62210316/5fbe0ccb-c0c8-4703-a470-56b17406ebfe)

### پرسش 4

در این الگو همه اصول SOLID نقض می‌شوند یا ممکن است نقض شوند.

- اصل SRP: چون امکان ارث‌بری از یک کلاس Singleton وجود ندارد، یک شیء از این کلاس به تنهایی باید به قسمت‌های مختلف کد پاسخگو باشد که این اصل SRP را نقض می‌کند.
- اصل OCP: در این اصل یکی از مصادیق Open بودن، داشتن امکان ارث‌بری است که یک کلاس Singleton این امکان را ندارد چون اگر از این کلاس ارث‌بری کنیم، فرزندان مطابق رابطه is-a خودشان یک کلاس Singleton هستند و از شیء درون کلاس (Instance) چند نمونه ساخته می‌شود که نقض غرض است.
- اصل LSP: چون همانطور که در اصل قبلی گفتیم، هم امکان ارث‌بری از کلاس Singleton وجود ندارد و هم از این کلاس فقط یک شیء داریم، پس این اصل اصلا در اینجا تعریف نمی‌شود. چون LSP به این معنی است که بتوان «همه فرزندان» یک کلاس را به جای آن جای‌گذاری کرد که همان امکانات کلاس والد را بدون نیاز به اصلاح داشته باشد.
- اصل ISP: چون نمی‌شود از کلاس Singleton ارث‌بری کرد، نمی‌شود functionality های به خصوص در این کلاس را به لایه‌های پایین‌تر که متخصص‌تر هستند انتقال داد که این در تضاد با اصل ISP است.
- اصل DIP: طبق این اصل باید هر جایی از برنامه که نیازی به استفاده از یک کلاس است تا حد امکان از Abstraction آن کلاس استفاده کنیم که چون برای استفاده از کلاس Singleton تنها راه استفاده مستقیم از خود این کلاس و تنها شیء آن است، این اصل نیز نقض می‌شود.
